# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Interface2.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

#удалить лишние вызолвы fn, ошибка в командах, global заменить на self, исправить получаемое значение в fn_send
import sys
import threading
import time
import random 
from PyQt5.QtWidgets import *
from PyQt5.QtWidgets import QMessageBox, QApplication, QPushButton, QWidget
from PyQt5 import QtCore, QtGui, QtWidgets, uic 
from time import time, sleep
from PyQt5.QtCore import QBasicTimer, QDateTime, QThread
from PyQt5.QtCore import pyqtSignal, QObject

from PyQt5.QtGui import QIcon, QFont, QPixmap
from PyQt5.QtCore import QCoreApplication, QBasicTimer, QDateTime, Qt, QSize, QTimer
import Interface

class MainWindow(QMainWindow, Interface.Ui_MainWindow):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__()
        self.setupUi(self)
        self.flow_value = ' '
        
        self.btn_openO.clicked.connect(self.click_openO) #функции нажатия на кнопки
        self.btn_openAr.clicked.connect(self.click_openAr)
        self.btn_closeO.clicked.connect(self.click_closeO)
        self.btn_closeAr.clicked.connect(self.click_closeAr)
        self.btn_regulateO.clicked.connect(self.click_regulateO)
        self.btn_regulateAr.clicked.connect(self.click_regulateAr)
        self.btn_installO.clicked.connect(self.click_installO)
        self.btn_installAr.clicked.connect(self.click_installAr)
        

        #self.Exit.clicked.connect(self.Exit_)                   # клик на кнопку ВЫХОД
        #GPIO.setmode(GPIO.BCM)                                  # Инициализация пина RPi - Master (используется при MAX485)
        #GPIO.setup(DU_Pin_Rpi_Master, GPIO.OUT)
        #GPIO.output(DU_Pin_Rpi_Master, True)
        self.setGeometry(0, 0, 1024, 600)                        # расположение главновго окна
        #self.setWindowFlags(Qt.FramelessWindowHint)             # убирает шапку приложения
        #icon_switch_off = QtGui.QIcon()                         # картинка на кнопке ВЫХОД
        #icon_switch_off.addPixmap(QtGui.QPixmap("/home/pi/Desktop/Modbus/close.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        #self.Exit.setIcon(icon_switch_off)                      # добавляет иконку
        #self.Exit.setIconSize(QtCore.QSize(57, 57))

    def showEvent(self, event): #запускает программу при при её открытии 
        global current_command 
        current_command = '010300040002'
        self.start_readout()

    def start_readout(self):
        global current_command 
        a = '010300040002'
        if current_command != a:
            print('модуль получил глобальную команду')
            thread1 = threading.Thread(target = self.fn_sendcmd, args=(current_command,) )
            thread1.start()
            thread1.join()
            current_command = '010300040002'
        else:
            print('modul 1 made/ ')
            thread1 = threading.Thread(target = self.fn_sendcmd, args=(a,) )
            thread1.start()
            thread1.join()
            self.updatelabeltextO(self.flow_value)
        timer = threading.Timer(2.0, self.second_part, args=(str,))
        timer.start()
 
    def second_part(self, str):
        a = '020300040002'
        print('modul 2 made /')
        thread1 = threading.Thread(target = self.fn_sendcmd, args=(a,) )
        thread1.start()
        thread1.join()
        self.updatelabeltextAr(self.flow_value)
        self.start_readout()

    def updatelabeltextAr(self, str):
        self.label_realflowAr.setText(str)

    def updatelabeltextO(self, str):
        self.label_realflowO.setText(str)

    def fn_sendcmd(self, number):                                       # извлекаем содержимое ячеек
        print("def fn_sendcmd получило значение - ", number)                         # данные
        self.ed_id= number[0:2]                           # адрес устройства ID
        self.ed_cmd=number[2:4]                           # номер команды
        self.ed_adr=number[4:8]                           # адрес регистра
        self.ed_count=number[8:17]                          # данные
        self.flow_value = str(random.randint(0,100))
        sleep(1)

    def Exit_(self):                                            # при выходе из программы
        s.close()                                               # закрываем порт
        #GPIO.cleanup()                                          # очищаем пины
        self.close()                                            # закрываем главное окно

    def get_bt(self, tmps):                                     # извлекаем число из поля txt
        bt=int(tmps[-2:],16)
        return bt

    def get_highlow(self,tmps):                                 # разбиваем строку на 2 байта
        tmpl=int(tmps[-2:],16)
        tmph=int(tmps[-4:-2],16)
        return tmph, tmpl

    def print_list(self, ls):
        str_result=""                                           # формируем строчку для вывода на экран (запрос)
        for ch in ls:
            if len(ch[2:])==1:
                str_result=str_result+"0"+ch[2:]+"  "
            else:
                str_result=str_result+ch[2:]+"  "
        return (str_result)

    def print_list2(self, ls):
        str_result=""                                           # формируем строчку для вывода на экран (ответ)
        for ch in ls:
            str_result=str_result+"  "+ch
        return (str_result[2:])

    def crc16bt(self, data):
        i_CRC_High=hex(0xFF)
        i_CRC_Low=hex(0xFF)
        index=hex(0x0000)
        for bt in data:
            index=(int(i_CRC_Low,16) ^ int(bt,16))              # index - в 10 сс
            i_CRC_Low=hex(int(i_CRC_High,16) ^ int(hex(CRC_High[index]),16))
            i_CRC_High=hex(int(hex(CRC_Low[index]),16))
        return (hex((int(i_CRC_High,16)<<8) | int(i_CRC_Low,16)))

    def addcrc(self, ls):                                       # вычисляет байты CRC и добавляет в конец list
        self.crc=self.crc16bt(ls)
        self.crc_low=hex(int(self.crc,16) & int(hex(0xFF),16))
        self.crc_high=hex((int(self.crc,16)>>8) & int(hex(0xFF),16))
        return self.crc_low, self.crc_high
    
    def click_openO(self):
        global current_command  
        current_command = "010F000200020101"
        type_command = "010F000200020101"
        print("def click_openO выполнено")

    def click_openAr(self):
        global current_command  
        current_command = "020F000200020101"
        type_command = "020F000200020101"
        print("def click_openAr выполнено")
        
    def click_closeO(self):
        global current_command  
        current_command = "010F000200020102"
        type_command = "010F000200020102"
        print("def click_closeO выполнено")

    def click_closeAr(self):
        global current_command  
        current_command = "020F000200020102"
        type_command = "020F000200020102"
        print("def click_closeAr выполнено")
        
    def click_regulateO(self):
        global current_command  
        current_command = "010F000200020100"
        type_command = "010F000200020100"
        print("def click_regulateO выполнено")
        
    def click_regulateAr(self):
        global current_command  
        current_command = "020F000200020100"
        type_command = "020F000200020100"
        print("def click_regulateAr выполнено")
        
    def click_installO(self):
        value_flow_1 = self.lineEdit.text() #значение из TextEdit в строку
        try:
            value_flow_1 = float(value_flow_1)
            procent = int((value_flow_1/90)*10000*1.45)
            procent1 = hex(procent)
            procent1=str(procent1)
            print("отчивка", procent1)
            if len(procent1) < 6:
                procent2 = "0" + procent1[2:6]
                print(procent2)
            else:
                procent2 = procent1[2:6]
            print("def click_installO выполнено", procent2)
            type_command = "01060004" + procent2
            print(type_command)
            global current_command  
            current_command = type_command
        except: 
            self.show_error(value_flow_1)

    def click_installAr(self):
        value_flow = self.text_givenAr.text() #значение из TextEdit в строку
        try:
            value_flow = float(value_flow)
            procent = int((value_flow/90)*10000*1.45)
            procent1 = hex(procent)
            procent1=str(procent1)
            print("отчивка", procent1)
            if len(procent1) < 6:
                procent2 = "0" + procent1[2:6]
                print(procent2)
            else:
                procent2 = procent1[2:6]
            print("def click_installO выполнено", procent2)
            type_command = "02060004" + procent2
            print(type_command)
            global current_command  
            current_command = type_command
        except: 
            self.show_error(value_flow)


    def show_error(self, number): #вывод ошибки 
        error = QMessageBox()
        error.setWindowTitle("Ошибка")
        error.setText('Введено некорректное значение потока ')
        error.setIcon(QMessageBox.Warning)
        error.setStandardButtons(QMessageBox.Ok)
        error.exec()


def main():                                                     # открытие главного окна
    app = QApplication(sys.argv)
    main_win = MainWindow()
    main_win.show()
    sys.exit(app.exec_())

if __name__ == "__main__": main()
